#!/usr/bin/env perl

use v5.10;
use strict;

use Data::Dumper;
use MongoDB;
use IO::Prompter;
use Getopt::Long;
use BalanceOfPower::World;
use BalanceOfPower::Interactive;
use BalanceOfPower::Utils qw(get_year_turns compare_turns prev_turn next_turn add_turns);

my $usage = "$0 COMMAND SCENARIO [STEPS]\n\nAvailable commands:\n  new\n  elaborate\n  delete\n  help\n";
my $first_year = 1970;

my $command = shift;
my $scenario = shift;

say "";
if($command eq 'new')
{
    die "No scenario" if ! $scenario;

    my $data = get_scenario($scenario); 
    die "Scenario already exists!" if $data;

    say "Creating scenario $scenario";   
    my $steps = shift || 5;
    
    my $logs = 0;
    my $world = BalanceOfPower::World->new( name => $scenario, first_year => $first_year, log_active => $logs, mongo_save => 1, mongo_runtime_db => 'bop_' . $scenario . '_runtime' );
    $world->init_random("nations-v2.txt", "borders-v2.txt");
    $world->dice_log(0);
    $world->autopilot($first_year, $first_year+$steps);
}
elsif($command eq 'delete')
{
    die "No scenario" if ! $scenario;

    my $data = get_scenario($scenario); 
    die "Scenario does not exists!" if ! $data;

    my $confirm = prompt "Are you sure (Y/N)? ";
    if($confirm eq 'Y')
    {
        my $client = MongoDB->connect();
        my $year = $data->{first_year} . '/1';
        while(compare_turns($year, $data->{current_year}) < 1)
        {
            my $db_name = 'bop_' . $scenario . '_'. $year;
            $db_name =~ s/\//_/;
            say "Deleting $db_name";
            $client->get_database($db_name)->drop;
            $year = next_turn($year);
        }
        $client->get_database('bop_' . $scenario . '_runtime')->drop;
        say "Deleting bop_$scenario" . '_runtime';
        $client->get_database('bop_' . $scenario . '_interactions')->drop;
        say "Deleting bop_$scenario" . '_interactions';
        my $db = $client->get_database("bop_games");
        $db->get_collection('games')->delete_one({ name => $scenario });
        say "Scenario deleted\n";
    }
}
elsif($command eq 'elaborate')
{
    my $data = get_scenario($scenario); 
    die "Scenario does not exists!" if ! $data;
    my $steps = shift || 1;
    my $world = BalanceOfPower::World->load_mongo($scenario, $data->{current_year}); 
    my $year = next_turn($data->{current_year});
    for(my $i = 0; $i < $steps; $i++)
    {
        say "Running turn";
        $world->elaborate_turn($year);
        say "Turn elaborated, dumping...";
        $world->dump_mongo();
        say $world->current_year . " elaborated...";
        $year = next_turn($year);
    }
}
elsif($command eq 'int-evaluate')
{
    my $turn = shift;
    my $int = BalanceOfPower::Interactive->new( game => $scenario );
    my $n, undef = $int->elaborate_values($turn);
    say Dumper($n);
}
elsif($command eq 'int-evaluate-range')
{
    my $start = shift;
    my $end = shift;
    my $file = shift;
    my $header = 0;
    my $int = BalanceOfPower::Interactive->new( game => $scenario );
    open(my $fh, "> $file");
    my $turn = $start;
    do
    {
        my ($n, undef) = $int->elaborate_values($turn);
        my ($sum, $counter, $average) = $int->elaborate_average($turn);
        if(! $header)
        {
            my $line = "";
            for(sort keys %{$n})
            {
                $line .= $_ . ";"
            }
            $line .= "\n";
            print {$fh} $line;
            $header = 1;
        }
        my $line = "";
        for(sort keys %{$n})
        {
            my $v = $n->{$_} - $average;
            $v = sprintf("%.2f", $v);
            $line .= $v . ";"
        }
        $line .= "\n";
        print {$fh} $line;
        $turn = next_turn($turn);
    }
    while($turn ne $end);
    close($fh);
}
elsif($command eq 'int-evaluate-explain')
{
    my $turn = shift;
    my $nation = shift;
    my $int = BalanceOfPower::Interactive->new( game => $scenario );
    my ($n, $e)  = $int->elaborate_values($turn);
    print "\n";
    say "VALUE FOR $nation: " . $n->{$nation};
    say "----";
    for(@{$e->{$nation}})
    {
        say $_
    }
    say "---\n";
}
elsif($command eq 'game')
{
    my $game_data = get_scenario($scenario); 
    my $player_data = get_player($scenario);
    my $int = BalanceOfPower::Interactive->new( game => $scenario );
    say "Player current turn: " . $player_data->{current_year};
    say "Game current turn: " .  $game_data->{current_year};
    if(compare_turns($player_data->{current_year}, $game_data->{current_year}) == -1)
    {
        my $to_elaborate = $player_data->{current_year};
        while($to_elaborate ne $game_data->{current_year})
        {
            $to_elaborate = next_turn($player_data->{current_year});
            my ($bets, $collected, $archived) = get_active_bets($scenario, $to_elaborate);
            my $c = 0;
            foreach my $b (@{$bets})
            {
                $c++;
                my $n_value = $int->calculate_bet_return($to_elaborate, $b);
                update_bet($scenario, $to_elaborate, $b->{nation}, $n_value);
            }
            update_player($scenario, $player_data->{name}, $to_elaborate, $player_data->{funds} + $collected);
            say "Values for " . $player_data->{name} . " on $to_elaborate done. $c bets updated, $archived bets archived";
        }
    }
    else
    {
        say "No turn to run";
    } 
}
elsif($command eq 'help')
{
    say $usage;
}
else
{
    say "Bad command or no command provided\n";
    say $usage;
}

sub get_scenario
{
    my $scenario = shift;
    my $client = MongoDB->connect();
    my $db = $client->get_database("bop_games");
    my ($data) = $db->get_collection('games')->find({ name => $scenario })->all;
    return $data;
}
sub get_player
{
    my $scenario = shift;
    my $client = MongoDB->connect();
    my $db = $client->get_database('bop_' . $scenario . '_interactions');
    my ($data) = $db->get_collection('players')->find()->all();
    return $data;
}
sub get_active_bets
{
    my $scenario = shift;
    my $turn = shift;;
    my $client = MongoDB->connect();
    my $db = $client->get_database('bop_' . $scenario . '_interactions');
    my @bets = $db->get_collection('bets')->find()->all();
    my @ok = ();
    my $collected = 0;
    my $c = 0;
    foreach my $b (@bets)
    {
        my $end = add_turns($b->{start_year}, $b->{duration});
        if(compare_turns($turn, $end) <= 0)
        {
            push @ok, $b;
        }
        else
        {
            $c++;
            $db->get_collection('bets')->delete_one({ nation => $b->{nation} });
            $collected += $b->{value}; 
            $db->get_collection('bets_archive')->insert_one($b)
        }
    }
    return \@ok, $collected, $c;
}
sub update_bet
{
    my $scenario = shift;
    my $turn = shift;
    my $nation = shift;
    my $value = shift;
    my $client = MongoDB->connect();
    my $db = $client->get_database('bop_' . $scenario . '_interactions');
    $db->get_collection('bets')->update_one( { nation => $nation }, { '$set' => { value => $value}});
}
sub update_player
{
    my $scenario = shift;
    my $player = shift;
    my $turn = shift;
    my $funds = shift;
    my $client = MongoDB->connect();
    my $db = $client->get_database('bop_' . $scenario . '_interactions');
    $db->get_collection('players')->update_one( { name => $player }, { '$set' => { funds => $funds, current_year => $turn}});
}
